---
title: java基础 多线程
date: 2020/09/16
tags: 
    - java
---

# 介绍与概念
- Java 给多线程编程提供了内置的支持。 一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。
- 多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销。
- 进程：是代码在数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位。
- 线程：是进程的一个执行路径，一个进程中至少有一个线程，进程中的多个线程共享进程的资源，但是每个线程有自己的程序计数器和栈区域。一个线程不能独立的存在，它必须是进程的一部分。一个进程一直运行，直到所有的非守护线程都结束运行后才能结束。
    - 每个线程有自己的程序计数器和栈区域。
- 虽然系统是把资源分给进程，但是CPU很特殊，是被分配到线程的，所以线程是CPU分配的基本单位。多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。
- 程序计数器：是一块内存区域，用来记录线程当前要执行的指令地址 。
- 栈：用于存储该线程的局部变量，这些局部变量是该线程私有的，除此之外还用来存放线程的调用栈祯。
- 堆：是一个进程中最大的一块内存，堆是被进程中的所有线程共享的。
- 方法区：则用来存放 NM 加载的类、常量及静态变量等信息，也是线程共享的 。
- 总结
    - 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。
    - 线程的划分尺度小于进程，使得多线程程序的并发性高。
    - 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。
    - 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。
    - 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。

# 生命周期
线程是一个动态执行的过程，它也有一个从产生到死亡的过程。
- 新建状态
    - 使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。
- 就绪状态:
    - 当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。
- 运行状态:
    - 如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
- 阻塞状态:
    - 如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种：
        - 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。
        - 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。
        - 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。
- 死亡状态:
    - 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

问：Java 程序每次运行至少启动几个线程？
至少启动两个线程，每当使用 Java 命令执行一个类时，实际上都会启动一个 JVM，每一个JVM实际上就是在操作系统中启动一个线程，Java 本身具备了垃圾的收集机制。所以在 Java 运行时至少会启动两个线程，一个是 main 线程，另外一个是垃圾收集线程。

# 并发与并行
- 并发：是指同一个时间段内多个任务同时都在执行，并且都没有执行结束。并发任务强调在一个时间段内同时发起，而一个时间段由多个单位时间累积而成，所以说并发的多个任务在单位时间内不一定同时在执行 。
- 并行：是说在单位时间内多个任务同时在执行 。

在多线程编程实践中，线程的个数往往多于CPU的个数，所以一般都称多线程并发编程而不是多线程并行编程。
## 并发常见问题
- 线程安全
    - 多线程共享数据，更新与获取到的数值不一致，导致数值错乱问题。
- 共享内存不可见性
    - Java 内存模型规定，将所有的变量都存放在主内存中，当线程使用变量时，会把主内存里面的变量复制到自己的工作空间或者叫作工作内存，线程读写变量时操作的是自己工作内存中的变量 。
    - 但是实际情况会存在部分内存存在不共享情况，比如主内存、二级缓存是共享的，一级缓存不共享。获取数据一级>二级>主内存>数据库，在一级缓存是存在数据不一致情况。
- synchronized的理解
    - 这个内存语义就可以解决共享变量内存可见性问题。
    - 进入synchronized块的内存语义是把在synchronized块内使用到的变量从线程的工作内存中清除，这样在synchronized块内使用到该变量时就不会从线程的工作内存中获取，而是直接从主内存中获取。退出synchronized块的内存语义是把在synchronized块内对共享变量的修改刷新到主内存。会造成上下文切换的开销，独占锁，降低并发性。
- Volatile的理解
    - 该关键字可以确保对一个变量的更新对其他线程马上可见。
    - 当一个变量被声明为volatile时，线程在写入变量时不会把值缓存在寄存器或者其他地方，而是会把值刷新回主内存。当其他线程读取该共享变量时，会从主内存重新获取最新值，而不是使用当前线程的工作内存中的值。
    - volatile的内存语义和synchronized有相似之处，具体来说就是，当线程写入了volatile变量值时就等价于线程退出synchronized同步块（把写入工作内存的变量值同步到主内存），读取volatile变量值时就相当于进入同步块（先清空本地内存变量值，再从主内存获取最新值）。
    - volatile能保证原子性，但是对自增和自减的多原子操作不能保证原子性。

# 线程的优先级
- 每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。
- Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。
- 默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。
- 具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。

# 创建一个线程
## 通过继承 Thread 类本身或者匿名实现
继承demo
```
public class ThreadDemo extends Thread{
    @Override
    public void run() {
        //具体实现代码
    }
}
```
```
public class Demo{
    public static void main(String[] args) throws Exception {
        new ThreadDemo().start();
    }
}
```
匿名实现demo
```
public class Demo{
    public static void main(String[] args) throws Exception {
         new Thread(){
            @Override
            public void run() {
                //具体实现
            }
        }.start();
    }
}
```
## 通过实现 Runnable 接口
```
public class RunnableDemo implements Runnable{
    @Override
    public void run() {
        //具体实现代码
    }
}

```
```
public class Demo{
    public static void main(String[] args) throws Exception {
        new Thread(new RunnableDemo()).start();
    }
}
```
## 通过 Callable 和 Future 创建线程
```
public class CallableDemo implements Callable<String>{
    @Override
    public String call() throws Exception {
        try {
            Thread.sleep(5000);
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        return "1111";
    }
}
```
```
public class Demo{
        FutureTask<String> futureTask = new FutureTask<>(new CallableDemo());
        new Thread(futureTask).start();
        System.out.println(futureTask.get());//会等线程跑完才会输出
}
```

# Thread类详解
## 初始化方法
```
/**
 * Initializes a Thread.
 * @param g 线程组
 * @param target 执行对象
 * @param name 线程名
 * @param stackSize 新线程栈大小，为0表示忽略
 * @param acc用于继承的访问控制上下文
 * @param inheritThreadLocals如果值为true,从构造线程继承可继承线程局部变量的初始值
*/
private void init(ThreadGroup g, Runnable target, String name, long stackSize, AccessControlContext acc) {
    if (name == null) {
        throw new NullPointerException("name cannot be null");
    }
    this.name = name.toCharArray();
    Thread parent = currentThread();
    SecurityManager security = System.getSecurityManager();
    //线程组为null，获取当前已托管的线程组或者父线程的线程组
    if (g == null) {
        if (security != null) {
            g = security.getThreadGroup();
        }
        if (g == null) {
            g = parent.getThreadGroup();
        }
    }
    //线程组检查
    g.checkAccess();
    if (security != null) {
        if (isCCLOverridden(getClass())) {
            security.checkPermission(SUBCLASS_IMPLEMENTATION_PERMISSION);
        }
    }
    g.addUnstarted();
    this.group = g;
    this.daemon = parent.isDaemon();//沿用父线程的设置
    this.priority = parent.getPriority();//沿用父线程的设置
    if (security == null || isCCLOverridden(parent.getClass()))
        this.contextClassLoader = parent.getContextClassLoader();
    else
        this.contextClassLoader = parent.contextClassLoader;
    this.inheritedAccessControlContext =
            acc != null ? acc : AccessController.getContext();
    this.target = target;
    setPriority(priority);
    if (parent.inheritableThreadLocals != null)
        this.inheritableThreadLocals =
            ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
    this.stackSize = stackSize;
    tid = nextThreadID();
}
```
## 构造方法
Thread的构造方法都调用init()方法
每个线程均分配一个name，默认为（Thread-自增数字）的组合
```
public Thread() {
    init(null, null, "Thread-" + nextThreadNum(), 0);
}
```
```
public Thread(Runnable target) {
    init(null, target, "Thread-" + nextThreadNum(), 0);
}
```
```
Thread(Runnable target, AccessControlContext acc) {
    init(null, target, "Thread-" + nextThreadNum(), 0, acc);
}
```
```
public Thread(ThreadGroup group, Runnable target) {
    init(group, target, "Thread-" + nextThreadNum(), 0);
}
```
```
public Thread(String name) {
    init(null, null, name, 0);
}
```
```
public Thread(ThreadGroup group, String name) {
    init(group, null, name, 0);
}
```
```
public Thread(Runnable target, String name) {
    init(null, target, name, 0);
}
```
```
public Thread(ThreadGroup group, Runnable target, String name) {
    init(group, target, name, 0);
}
```
```
public Thread(ThreadGroup group, Runnable target, String name, long stackSize) {
    init(group, target, name, stackSize);
}
```
## 线程状态
```
public enum State {
    NEW,
    RUNNABLE,
    BLOCKED,
    WAITING,
    TIMED_WAITING,
    TERMINATED;
}
```
- NEW
    - 一个尚未启动的线程处于这一状态。
- RUNNABLE
    - 就绪状态，处于就绪状态的线程位于可运行池中，此时它只是具备了运行的条件，能否获得 CPU 的使用权开始运行，还需要等待系统的调度。
    - 线程正常运行
    - 线程处于等待，但依旧是这个状态。一般发生在某种耗时计算/IO等待/CPU时间片切换等需要等待其他系统资源的情况。被动等待。
- BLOCKED
    - 等待进入synchronized块，排队等待中。
- WAITING
    - 正在等待，wait
- TIMED_WAITING
- TERMINATED