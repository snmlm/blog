---
title: 动态规划
date: 2019/03/05
tags: 
    - 算法
    - 动态规划
---

# 动态规划
## 解释
* 通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。动态规划常常适用于有重叠子问题和最优子结构性质的问题。

## 基本思想
* 若要解一个给定问题，我们需要解其不同部分（即子问题），再合并子问题的解以得出原问题的解。 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量： 一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。

这种做法在重复子问题的数目关于输入的规模呈指数增长时特别有用。

## 分治与动态规划
* 共同点：二者都要求原问题具有最优子结构性质,都是将原问题分而治之,分解成若干个规模较小(小到很容易解决的程序)的子问题.然后将子问题的解合并,形成原问题的解.
* 不同点：分治法将分解后的子问题看成相互独立的，通过用递归来做。

&emsp;&emsp;动态规划将分解后的子问题理解为相互间有联系,有重叠部分，需要记忆，通常用迭代来做。

## 问题特征
* 最优子结构：当问题的最优解包含了其子问题的最优解时，称该问题具有最优子结构性质。
* 重叠子问题：在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。动态规划算法正是利用了这种子问题的重叠性质，对每一个子问题只解一次，而后将其解保存在一个表格中，在以后尽可能多地利用这些子问题的解。

## 步骤
* 描述最优解的结构
* 递归定义最优解的值
* 按自底向上的方式计算最优解的值
* 由计算出的结果构造一个最优解

# 背包问题
## 题目01 基本背包问题 
&emsp;&emsp;有N件物品和一个容量为V的背包。第i件物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 

### 基本思路
&emsp;&emsp;这是最基础的背包问题，特点是：每种物品仅有一件，可以选择放或不放。

&emsp;&emsp;用子问题定义状态：即`f[i][v]`表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：`f[i][v]=max{f[i-1][v],f[i-1][v-c[i]]+w[i]}`。

&emsp;&emsp;这个方程非常重要，基本上所有跟背包相关的问题的方程都是由它衍生出来的。所以有必要将它详细解释一下：“将前i件物品放入容量为v的背包中”这个子问题，若只考虑第i件物品的策略（放或不放），那么就可以转化为一个只牵扯前i-1件物品的问题。如果不放第i件物品，那么问题就转化为“前i-1件物品放入容量为v的背包中”；如果放第i件物品，那么问题就转化为“前i-1件物品放入剩下的容量为`v-c[i]`的背包中”，此时能获得的最大价值就是`f [i-1][v-c[i]]`再加上通过放入第i件物品获得的价值`w[i]`。

&emsp;&emsp;注意`f[i][v]`有意义当且仅当存在一个前i件物品的子集，其费用总和为v。所以按照这个方程递推完毕后，最终的答案并不一定是`f[N] [V]`，而是`f[N][0..V]`的最大值。如果将状态的定义中的“恰”字去掉，在转移方程中就要再加入一项`f[i][v-1]`，这样就可以保证`f[N] [V]`就是最后的答案。至于为什么这样就可以，由你自己来体会了。 
### 优化空间复杂度 
&emsp;&emsp;以上方法的时间和空间复杂度均为`O(N*V)`，其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到`O(V)`。

&emsp;&emsp;先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组`f[i][0..V]`的所有值。那么，如果只用一个数组`f [0..V]`，能不能保证第i次循环结束后`f[v]`中表示的就是我们定义的状态`f[i][v]`呢？`f[i][v]`是由`f[i-1][v]`和`f[i-1] [v-c[i]]`两个子问题递推而来，能否保证在推`f[i][v]`时（也即在第i次主循环中推`f[v]`时）能够得到`f[i-1][v]`和`f[i-1][v -c[i]]`的值呢？事实上，这要求在每次主循环中我们以v=V..0的顺序推`f[v]`，这样才能保证推`f[v]时f[v-c[i]]`保存的是状态`f[i -1][v-c[i]]`的值。伪代码如下： 
```
for i=1..N 
for v=V..0 
f[v]=max{f[v],f[v-c[i]]+w[i]}; 
```
&emsp;&emsp;其中的`f[v]=max{f[v],f[v-c[i]]}`一句恰就相当于我们的转移方程`f[i][v]=max{f[i-1][v],f[i- 1][v-c[i]]}`，因为现在的`f[v-c[i]]`就相当于原来的`f[i-1][v-c[i]]`。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了`f[i][v]`由`f[i][v-c[i]]`推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。 
### 总结 
&emsp;&emsp;01背包问题是最基本的背包问题，它包含了背包问题中设计状态、方程的最基本思想，另外，别的类型的背包问题往往也可以转换成01背包问题求解。故一定要仔细体会上面基本思路的得出方法，状态转移方程的意义，以及最后怎样优化的空间复杂度。
## 题目02 完全背包问题
&emsp;&emsp;有N种物品和一个容量为V的背包，每种物品都有无限件可用。第i种物品的费用是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。 

### 基本思路 
&emsp;&emsp;这个问题非常类似于01背包问题，所不同的是每种物品有无限件。也就是从每种物品的角度考虑，与它相关的策略已并非取或不取两种，而是有取0件、取1件、取2件……等很多种。如果仍然按照解01背包时的思路，令`f[i][v]`表示前i种物品恰放入一个容量为v的背包的最大权值。仍然可以按照每种物品不同的策略写出状态转移方程，像这样：`f[i][v]=max{f[i-1][v-k*c[i]]+k*w[i]|0<=k*c[i]<= v}`。这跟01背包问题一样有`O(N*V)`个状态需要求解，但求解每个状态的时间则不是常数了，求解状态`f[i][v]`的时间是`O(v/c[i])`，总的复杂度是超过`O(VN)`的。

&emsp;&emsp;将01背包问题的基本思路加以改进，得到了这样一个清晰的方法。这说明01背包问题的方程的确是很重要，可以推及其它类型的背包问题。但我们还是试图改进这个复杂度。

### 一个简单有效的优化 
&emsp;&emsp;完全背包问题有一个很简单有效的优化，是这样的：若两件物品i、j满足`c[i]<=c[j]`且`w[i]>=w[j]`，则将物品j去掉，不用考虑。这个优化的正确性显然：任何情况下都可将价值小费用高得j换成物美价廉的i，得到至少不会更差的方案。对于随机生成的数据，这个方法往往会大大减少物品的件数，从而加快速度。然而这个并不能改善最坏情况的复杂度，因为有可能特别设计的数据可以一件物品也去不掉。

### 转化为01背包问题求解
&emsp;&emsp;既然01背包问题是最基本的背包问题，那么我们可以考虑把完全背包问题转化为01背包问题来解。最简单的想法是，考虑到第i种物品最多选`V/c [i]`件，于是可以把第i种物品转化为V/c[i]件费用及价值均不变的物品，然后求解这个01背包问题。这样完全没有改进基本思路的时间复杂度，但这毕竟给了我们将完全背包问题转化为01背包问题的思路：将一种物品拆成多件物品。

### 更高效的转化方法
&emsp;&emsp;把第i种物品拆成费用为`c[i]*2^k`、价值为`w[i]*2^k`的若干件物品，其中k满足`c[i]*2^k<V`。这是二进制的思想，因为不管最优策略选几件第i种物品，总可以表示成若干个2^k件物品的和。这样把每种物品拆成`O(log(V/c[i]))`件物品，是一个很大的改进。但我们有更优的`O(VN)`的算法。` * O(VN)`的算法这个算法使用一维数组，先看伪代码：
```
for i=1..N 
for v=0..V 
f[v]=max{f[v],f[v-c[i]]+w[i]};
```
&emsp;&emsp;你会发现，这个伪代码与P01的伪代码只有v的循环次序不同而已。为什么这样一改就可行呢？首先想想为什么P01中要按照v=V..0的逆序来循环。这是因为要保证第i次循环中的状态`f[i][v]`是由状态`f[i-1][v-c[i]]`递推而来。换句话说，这正是为了保证每件物品只选一次，保证在考虑“选入第i件物品”这件策略时，依据的是一个绝无已经选入第i件物品的子结果`f[i-1][v-c[i]]`。而现在完全背包的特点恰是每种物品可选无限件，所以在考虑“加选一件第i种物品”这种策略时，却正需要一个可能已选入第i种物品的子结果`f[i][v-c[i]]`，所以就可以并且必须采用v= 0..V的顺序循环。这就是这个简单的程序为何成立的道理。 

&emsp;&emsp;这个算法也可以以另外的思路得出。例如，基本思路中的状态转移方程可以等价地变形成这种形式：`f[i][v]=max{f[i-1][v],f[i][v-c[i]]+w[i]}`，将这个方程用一维数组实现，便得到了上面的伪代码。 

### 总结 
&emsp;&emsp;完全背包问题也是一个相当基础的背包问题，它有两个状态转移方程，分别在“基本思路”以及“`O(VN)`的算法“的小节中给出。希望你能够对这两个状态转移方程都仔细地体会，不仅记住，也要弄明白它们是怎么得出来的，最好能够自己想一种得到这些方程的方法。事实上，对每一道动态规划题目都思考其方程的意义以及如何得来，是加深对动态规划的理解、提高动态规划功力的好方法。