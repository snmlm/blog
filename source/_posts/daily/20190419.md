---
title: java总结
categories: 总结
tags: 
	- java
---
### 基本数据类型

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{% post_link 20190415_2 %}

<!-- more -->

### 引用类型
#### 数组
##### 排序
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{% post_link 20190418_1 %}
* 二分法查找
* Arrays（工具类   sort（二分法排序））

#### 字符串

##### String
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;是常量字符串（final类，值不变，改变的是指向的内存地址）
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;缺点：频繁拼接字符串非常耗内存

##### StringBulider，StringBuffer
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;值是可以改变的，长度可变
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer 与 StringBuilder 中的方法和功能完全是等价的，只是StringBuffer中的方法大都采用了 synchronized 关键字进行修饰，因此是线程安全的，而 StringBuilder 没有这个修饰，可以被认为是线程不安全的。 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于完全等价，所以都继承AbstractStringBuilder。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无参初始化，长度为16，有参初始化是参数长度+16。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;扩容时是对象当前长度*2+2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次append的时候，最下层执行的System.arraycopy这个方法进行数组的添加。
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuffer 始于 JDK 1.0 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;StringBuilder 始于 JDK 1.5 
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从 JDK 1.5 开始，带有字符串变量的连接操作（+），JVM 内部采用的是 StringBuilder 来实现的，而之前这个操作是采用 StringBuffer 实现的。如果是直接的字符串的拼接，会直接指向拼接后的字符串常量。

#### 自定义创建的对象
##### 内部类
##### 代码块
* 静态代码块（类相同的代码）
* 构造代码块（对象相同的代码）
* 局部代码块（）

##### 重载
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;方法名相同，形参列表不同。
##### 重写
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;子类继承覆盖。
##### 继承（加载顺序）

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{% post_link 20190415_1 %}

#### 集合
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map不是集合 Collection的接口下的都是集合，map不是子类
##### List
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;有序能重复
###### ArrayList
###### LinkedList
##### Set
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;无序不能重复
###### HashSet
###### TreeSet 
比较器接口
#### 图 Map
##### HashMap
##### LinkedHashMap
#### 接口
接口和抽象类
#### 基本类型对应的引用类型
1> byte       ------    Byte
2> short      ------   Short
3> int          ------    Integer
4> long       ------    Long
5> char       ------    Character
6> float       ------    Float
7> double   ------    Double
8> boolean ------    Boolean
 想搞清楚各种基本数据类型占用的字节数，首先要有一些基本知识，例：计算机最小的存储单位是 位(bit)，而一个字节等于8位即（1byte = 8bit)

#### 强引用,软引用,弱引用,虚引用

### 访问权限修饰符
public private（本包本类） protected（本包不本类 自类能用）
默认不属于权限修饰符 不能继承
### java中对象分类
a.runnable class（）主类（运行类）含有main方法，可以直接执行
b.java bean（） （不含有main方法，构造方法，set get 方法）
c.POJO对象（简单的java对象，只含有set get方法）
### 面向对象
a.封装（维护性）：隐藏成员变量和方法，隐藏共能实现的具体细节
b.继承（可扩展性）：子类继承父类的变量或者方法，也可以定义自己的
c.多态（灵活性）：父类的引用指向子类的实力（上转型对象）
### java中的两大机制：（跨平台）
a.JVM java虚拟机
b.GC 垃圾回收
### 异常
程序中出现的不正常的情况（会阻止程序的继续运行）（子类不能抛出比父类更多的异常，可以抛出父类的子异常）
1.编译异常（概率发生高的定义为编译异常）Exception直接子类
2.运行异常（概率发生低的定义为运行异常）继承RuntimeException
### 循环
1.for
2.foreach
3.do while
4.while
5.递归
    1.构造方法不能递归、
    2.必须有出口，if判断，否则死循环（肯定内存溢出）
    3.次数不易过多，否则会出现内存溢出
    递归解决问题的思想：（大->小）
    将大问题拆成小问题
6.if go(java中go无用，字段保留)
### 线程
线程与进程
start（）方法和run（）方法的区别？
    run方法只是一个普通的方法（还是单线程）
    start方法启动多线程，其次自动调用run方法
Thread，Runnable，callable
使用ExecutorService、Callable、Future实现有返回结果的线程
### 设计模式
23种
3类：
a.创建型
b.模板型
c.功能型
单例，工厂，装饰，代理等。
### 对象的序列化和反序列化
a.序列化：将对象以二进制的形式存储到硬盘中
b.反序列化：将以二进制形式的对象读取到内存中
要求：被序列化的对象必须要实现Serializable（标记接口）接口
不被序列化的字段处理，SerializableID问题
### XML格式，json格式
#### XML
读取，格式化等
DOM
SAX
JDOM
DOM4J
#### json
读取，格式化等
jsonobject
gson
fastjson
等
### 网络编程
在日本东京大学申请ip地址
UDP 不用连接
TCP 三次握手 
一个好的通讯软件（io流技术，多线程，udp tcp技术）
### 关键字
1.transient（在对象序列化的时候，如果某个属性不想被序列化就是该关键字修饰）
2.abstract：
a.修饰类（被他修饰的类为抽象类）
b.修饰方法（权限：public protected，抽象方法不能有方法体）
3.final：
a.修饰类：不能有子类
b.修饰方法：不能被重写 （不能修饰抽象方法）
c.修饰变量：常量（要赋初始值）
4.implements：实现接口
5.static：
a.修饰类：（内部类）
b.静态变量是属于类的，对象共享
c.修饰方法：静态方法只能调用的静态的东西
6.instanceof：
eg：a instanceof A：判断对象a是不是类A及其子类创建的实力
final finally，顺道finalize()

### 泛型
### IO
IO(BIO) 同步堵塞
NIO 同步非堵塞
AIO 异步（非）堵塞
